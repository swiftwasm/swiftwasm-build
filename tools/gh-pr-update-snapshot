#!/usr/bin/env python3

import os
import json
import subprocess
import urllib.request


def latest_build(swift_webroot):
    latest_build_endpoint = f"{swift_webroot}/latest-build.yml"
    with urllib.request.urlopen(latest_build_endpoint) as response:
        yaml_content = response.read().decode('utf-8')
        for line in yaml_content.splitlines():
            if line.startswith("dir: "):
                return line.split(" ")[1]
    return None


def replace_file_content(path: str, target: str, replacement: str):
    with open(path, 'r') as file:
        filedata = file.read()

    filedata = filedata.replace(target, replacement)

    with open(path, 'w') as file:
        file.write(filedata)


def open_pr_to_update_base_tag(scheme: str, base_tag: str, latest_tag: str,
                               interactive: bool):
    branch = f"update-base-tag/{scheme}-{latest_tag}"

    status = subprocess.run(
        ["git", "rev-parse", "--verify", branch],
        stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    if status.returncode == 0:
        print(f"Branch {branch} already exists, skipping")
        return

    status = subprocess.run(
        ["git", "ls-remote", "--exit-code", "--heads", "origin", branch],
        stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
    if status.returncode == 0:
        print(f"Branch {branch} already exists on remote, skipping")
        return

    subprocess.check_call(["git", "checkout", "-b", branch, "main"])

    replace_file_content(f"schemes/{scheme}/manifest.json",
                         base_tag, latest_tag)
    subprocess.check_call(["git", "add", f"schemes/{scheme}/manifest.json"])
    subprocess.check_call(
        ["git", "commit",
         "-m", f"Update base tag for {scheme} to {latest_tag}"])
    subprocess.check_call(["git", "push", "origin", branch])

    def github_compare(r1, r2):
        return f"https://github.com/apple/swift/compare/{r1}...{r2}"

    body = (f"Update base tag for {scheme} to {latest_tag}.\n\n"
            f"{github_compare(base_tag, latest_tag)}\n\n"
            "---\n"
            "Generated by [`./tools/gh-pr-update-snapshot`]("
            "https://github.com/swiftwasm/swiftwasm-build/"
            "blob/main/tools/gh-pr-update-snapshot)")

    subprocess.check_call([
        "gh", "pr", "create",
        "--title", f"Update base tag for {scheme} to {latest_tag}",
        "--label", "downstreaming",
        "--body", body,
        "--base", "main", "--head", branch] + (
            ["--web"] if interactive else []))
    subprocess.check_call(["git", "checkout", "-"])


REPO_ROOT = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))


def check_latest_build(scheme: str, interactive: bool):
    scheme_manifest = os.path.join(
        REPO_ROOT, "schemes", scheme, "manifest.json")
    with open(scheme_manifest) as f:
        manifest = json.load(f)
    channel = manifest['swift-org-download-channel']
    if channel.endswith("-release"):
        # Skip fixed release channels because they don't have latest-build.yml
        return

    swift_webroot = (
        f"https://download.swift.org/{channel}/ubuntu2204")
    base_tag = manifest["base-tag"]
    latest_tag = latest_build(swift_webroot)
    if base_tag != latest_tag:
        open_pr_to_update_base_tag(scheme, base_tag, latest_tag, interactive)


def main():
    import argparse

    parser = argparse.ArgumentParser()
    parser.add_argument("--no-interactive", action="store_true", default=False)

    args = parser.parse_args()

    for scheme in os.listdir(os.path.join(REPO_ROOT, "schemes")):
        check_latest_build(scheme, not args.no_interactive)


if __name__ == '__main__':
    main()
