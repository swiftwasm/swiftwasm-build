#!/usr/bin/env python3
# git-swift-workspace - A script to create a workspace for a Swift project applying patches
#
# Usage: git-swift-workspace [options]
#
# The basic flow of this script is:
# 1. `git clone https://github.com/apple/swift.git ../swift` if needed
# 2. `./swift/utils/update-checkout --clone --scheme <scheme>` to clone all the dependencies
# 3. `git am patches/<scheme>/*.patch` to apply all the patches

import os
import sys
import argparse
import json
import pathlib
import subprocess

def derive_options_from_args(argv):
    repo_root = os.path.dirname(os.path.dirname(__file__))
    schemes = [os.path.basename(path) for path in os.listdir(os.path.join(repo_root, 'schemes'))]

    parser = argparse.ArgumentParser(description='A script to create a workspace for a Swift project applying patches')
    parser.add_argument('--scheme', help='The scheme to use', required=True, choices=schemes)
    parser.add_argument('--tag', help='The upstream Swift tag to use as the base')
    parser.add_argument('--dry-run', help='Prints the commands that would be executed', action='store_true')
    parser.add_argument('-v', '--verbose', help='Prints the commands that are executed', action='store_true')
    parser.add_argument('--skip-history', help='Skip histories when obtaining sources', action='store_true')

    options = parser.parse_args(argv)

    manifest = json.load(open(os.path.join(repo_root, 'schemes', options.scheme, 'manifest.json')))

    if options.tag is None:
        options.tag = manifest['base-tag']
        if options.tag is None:
            raise Exception('Missing --tag option and no default tag for scheme {}'.format(options.scheme))

    options.repos = manifest['repos'] or {}
    return options

class Action:
    def __init__(self, options):
        self.options = options

    def run(self):
        raise Exception('Not implemented')

    def system(self, *args):
        if self.options.verbose or self.options.dry_run:
            print(' '.join(args), file=sys.stderr)
        if self.options.dry_run:
            return
        result = subprocess.run(args)
        if result.returncode != 0:
            raise Exception('Command failed: {}'.format(' '.join(args)))

class CloneAction(Action):
    def run(self):
        if os.path.exists("../swift/.git"):
            return
        print('=====> Cloning Swift repository')
        git_options = []
        if self.options.skip_history:
            git_options += ['--depth', '1', '--branch', self.options.tag]

        args = ['git', 'clone'] + git_options + ['https://github.com/apple/swift.git', '../swift']
        self.system(*args)

class UpdateCheckoutAction(Action):
    def run(self):
        print('=====> Updating checkout for scheme {} with tag {}'.format(self.options.scheme, self.options.tag))
        args = ['../swift/utils/update-checkout', '--clone', '--scheme', self.options.scheme, '--tag', self.options.tag]
        if self.options.skip_history:
            args += ['--skip-history']
        self.system(*args)

class ApplyPatchesAction(Action):
    def run(self):
        patches_dir = os.path.join('schemes', self.options.scheme, 'swift')
        patches = [os.path.join(patches_dir, path) for path in os.listdir(patches_dir)]
        patches.sort()
        print('=====> Applying {} patches for scheme {}'.format(len(patches), self.options.scheme))

        # If the repository is not clean, abort
        status = subprocess.run(['git', '-C', '../swift', 'status', '--porcelain']).returncode
        if status != 0:
            raise Exception('Repository is not clean. Please commit or stash your changes.')

        staging_branch = self.compute_unique_branch_name('swiftwasm-staging/{}'.format(self.options.tag))
        self.system('git', '-C', '../swift', 'switch', '-c', staging_branch)
        for patch in patches:
            repo_root_dirname = pathlib.Path(".").resolve().name
            relative_path = os.path.join("..", repo_root_dirname, patch)
            self.system('git', '-C', '../swift', 'am', '--keep-non-patch', str(relative_path))

    def compute_unique_branch_name(self, basename):
        name = basename
        suffix = 0
        while True:
            result = subprocess.run(['git', '-C', '../swift', 'branch', '--list', name], stdout=subprocess.PIPE)
            if len(result.stdout) == 0:
                return name
            suffix += 1
            name = '{}-{}'.format(basename, suffix)

class CheckoutCorelibsAction(Action):
    def run(self):
        print('=====> Checking out swift-corelibs for scheme {}'.format(self.options.scheme))
        for repo, rev in self.options.repos.items():
            fork_repo = f'https://github.com/swiftwasm/{repo}.git'
            status = subprocess.run(['git', '-C', f'../{repo}', 'remote', 'get-url', 'swiftwasm']).returncode
            if status != 0:
                self.system('git', '-C', f'../{repo}', 'remote', 'add', 'swiftwasm', fork_repo)
            print(f'Checking out {repo} at {rev}')
            self.system('git', '-C', f'../{repo}', 'fetch', 'swiftwasm', rev)
            self.system('git', '-C', f'../{repo}', 'checkout', rev)


class ActionRunner:
    def __init__(self, actions):
        self.actions = actions

    def run(self):
        repo_root = os.path.dirname(os.path.dirname(__file__))
        os.chdir(repo_root)
        for action in self.actions:
            action.run()

def main():
    options = derive_options_from_args(sys.argv[1:])
    actions = [CloneAction(options), UpdateCheckoutAction(options), ApplyPatchesAction(options), CheckoutCorelibsAction(options)]

    ActionRunner(actions).run()

if __name__ == '__main__':
    main()
