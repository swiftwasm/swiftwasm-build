#!/usr/bin/env python3
# git-swift-workspace - A script to create a workspace for a Swift project applying patches
#
# Usage: git-swift-workspace [options]
#
# The basic flow of this script is:
# 1. `git clone https://github.com/apple/swift.git ../swift` if needed
# 2. `./swift/utils/update-checkout --clone --scheme <scheme>` to clone all the dependencies
# 3. `git am patches/<scheme>/*.patch` to apply all the patches

import os
import sys
import argparse
import json
import pathlib
import subprocess

def derive_options_from_args(argv):
    repo_root = os.path.dirname(os.path.dirname(__file__))
    schemes = [os.path.basename(path) for path in os.listdir(os.path.join(repo_root, 'schemes'))]

    parser = argparse.ArgumentParser(description='A script to create a workspace for a Swift project applying patches')
    parser.add_argument('--scheme', help='The scheme to use', required=True, choices=schemes)
    parser.add_argument('--tag', help='The upstream Swift tag to use as the base')
    parser.add_argument('--dry-run', help='Prints the commands that would be executed', action='store_true')
    parser.add_argument('-v', '--verbose', help='Prints the commands that are executed', action='store_true')
    parser.add_argument('--skip-history', help='Skip histories when obtaining sources', action='store_true')

    options = parser.parse_args(argv)

    manifest = json.load(open(os.path.join(repo_root, 'schemes', options.scheme, 'manifest.json')))

    if options.tag is None:
        options.tag = manifest['base-tag']
        if options.tag is None:
            raise Exception('Missing --tag option and no default tag for scheme {}'.format(options.scheme))

    options.repos = manifest['repos'] or {}
    options.swift_org_download_channel = manifest['swift-org-download-channel']
    return options

class Action:
    def __init__(self, options):
        self.options = options

    def run(self):
        raise Exception('Not implemented')

    def system(self, *args):
        if self.options.verbose or self.options.dry_run:
            print(' '.join(args), file=sys.stderr)
        if self.options.dry_run:
            return
        result = subprocess.run(args)
        if result.returncode != 0:
            raise Exception('Command failed: {}'.format(' '.join(args)))

class CloneAction(Action):
    def run(self):
        if os.path.exists("../swift/.git"):
            return
        print('=====> Cloning Swift repository')
        git_options = []
        if self.options.skip_history:
            git_options += ['--depth', '1', '--branch', self.options.tag]

        args = ['git', 'clone'] + git_options + ['https://github.com/apple/swift.git', '../swift']
        self.system(*args)

class UpdateCheckoutAction(Action):
    def run(self):
        print('=====> Updating checkout for scheme {} with tag {}'.format(self.options.scheme, self.options.tag))
        args = ['../swift/utils/update-checkout', '--clone', '--scheme', self.options.scheme, '--tag', self.options.tag]
        if self.options.skip_history:
            args += ['--skip-history']
        self.system(*args)

class ApplyPatchesAction(Action):
    def run(self):
        patches_dir = os.path.join('schemes', self.options.scheme, 'swift')
        patches = [os.path.join(patches_dir, path) for path in os.listdir(patches_dir)]
        patches.sort()
        print('=====> Applying {} patches for scheme {}'.format(len(patches), self.options.scheme))

        # If the repository is not clean, abort
        status = subprocess.run(['git', '-C', '../swift', 'status', '--porcelain']).returncode
        if status != 0:
            raise Exception('Repository is not clean. Please commit or stash your changes.')

        staging_branch = self.compute_unique_branch_name('swiftwasm-staging/{}'.format(self.options.tag))
        self.system('git', '-C', '../swift', 'switch', '-c', staging_branch)
        for patch in patches:
            repo_root_dirname = pathlib.Path(".").resolve().name
            relative_path = os.path.join("..", repo_root_dirname, patch)
            self.system('git', '-C', '../swift', 'am', '--keep-non-patch', str(relative_path))

    def compute_unique_branch_name(self, basename):
        name = basename
        suffix = 0
        while True:
            result = subprocess.run(['git', '-C', '../swift', 'branch', '--list', name], stdout=subprocess.PIPE)
            if len(result.stdout) == 0:
                return name
            suffix += 1
            name = '{}-{}'.format(basename, suffix)

class CheckoutCorelibsAction(Action):
    def run(self):
        print('=====> Checking out swift-corelibs for scheme {}'.format(self.options.scheme))
        for repo, rev in self.options.repos.items():
            fork_repo = f'https://github.com/swiftwasm/{repo}.git'
            status = subprocess.run(['git', '-C', f'../{repo}', 'remote', 'get-url', 'swiftwasm']).returncode
            if status != 0:
                self.system('git', '-C', f'../{repo}', 'remote', 'add', 'swiftwasm', fork_repo)
            print(f'Checking out {repo} at {rev}')
            self.system('git', '-C', f'../{repo}', 'fetch', 'swiftwasm', rev)
            self.system('git', '-C', f'../{repo}', 'checkout', rev)

class DownloadBaseSnapshotAction(Action):
    def run(self):
        base_tag = self.options.tag
        platform = self.platform_info()
        tarball_name = f"{base_tag}-{platform[1]}.tar.gz"
        snapshot_url = f"https://download.swift.org/{self.options.swift_org_download_channel}/{platform[0]}/{base_tag}/{tarball_name}"

        base_snapshot_dir = os.path.join('..', 'build', 'Packaging', 'base-snapshot')
        os.makedirs(base_snapshot_dir, exist_ok=True)

        tarball_path = os.path.join(base_snapshot_dir, tarball_name)
        if not os.path.exists(tarball_path):
            print(f"=====> Downloading base snapshot {tarball_name}")
            self.system('curl', '-L', '-o', tarball_path, snapshot_url)

        unpacked_dir = os.path.join(base_snapshot_dir, f"{base_tag}-{platform[1]}")
        if not os.path.exists(unpacked_dir):
            print(f"=====> Unpacking base snapshot {tarball_name}")
            self.system('tar', '-C', base_snapshot_dir, '-xzf', tarball_path)

    def platform_info(self):
        uname = os.uname()
        if uname.sysname == "Darwin":
            # https://download.swift.org/development/xcode/swift-DEVELOPMENT-SNAPSHOT-2023-06-17-a/swift-DEVELOPMENT-SNAPSHOT-2023-06-17-a-osx.pkg
            return ["xcode", "osx"]
        elif uname.sysname == "Linux":
            release_lines = open("/etc/os-release").read().splitlines()
            if "ID=ubuntu" in release_lines:
                # https://download.swift.org/development/ubuntu2004/swift-DEVELOPMENT-SNAPSHOT-2023-06-17-a/swift-DEVELOPMENT-SNAPSHOT-2023-06-17-a-ubuntu20.04.tar.gz
                # https://download.swift.org/development/ubuntu2004-aarch64/swift-DEVELOPMENT-SNAPSHOT-2023-06-17-a/swift-DEVELOPMENT-SNAPSHOT-2023-06-17-a-ubuntu20.04-aarch64.tar.gz
                arch_suffix = f"-{uname.machine}" if uname.machine != "x86_64" else ""
                if 'VERSION_ID="18.04"' in release_lines:
                    return [f"ubuntu1804{arch_suffix}", f"ubuntu18.04{arch_suffix}"]
                elif 'VERSION_ID="20.04"' in release_lines:
                    return [f"ubuntu2004{arch_suffix}", f"ubuntu20.04{arch_suffix}"]
                elif 'VERSION_ID="22.04"' in release_lines:
                    return [f"ubuntu2204{arch_suffix}", f"ubuntu22.04{arch_suffix}"]
                elif 'VERSION_ID="22.04"' in release_lines:
                    return [f"ubuntu2204{arch_suffix}", f"ubuntu22.04{arch_suffix}"]
                raise Exception("Unsupported Ubuntu version!?")
            elif "ID=amzn" in release_lines:
                # https://download.swift.org/development/amazonlinux2/swift-DEVELOPMENT-SNAPSHOT-2023-06-17-a/swift-DEVELOPMENT-SNAPSHOT-2023-06-17-a-amazonlinux2.tar.gz
                if 'VERSION_ID="2"' in release_lines:
                    return ["amazonlinux2", "amazonlinux2"]
                raise Exception("Unsupported AmazonLinux version!?")
            raise Exception("Unsupported Linux distribution")


class ActionRunner:
    def __init__(self, actions):
        self.actions = actions

    def run(self):
        repo_root = os.path.dirname(os.path.dirname(__file__))
        os.chdir(repo_root)
        for action in self.actions:
            action.run()

def main():
    options = derive_options_from_args(sys.argv[1:])
    actions = [CloneAction(options), UpdateCheckoutAction(options), ApplyPatchesAction(options), CheckoutCorelibsAction(options), DownloadBaseSnapshotAction(options)]

    ActionRunner(actions).run()

if __name__ == '__main__':
    main()
