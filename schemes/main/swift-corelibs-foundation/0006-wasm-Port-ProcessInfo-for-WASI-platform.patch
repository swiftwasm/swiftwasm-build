From b292e9c5b58de43b6a3abcc49f4aabdc22e5b14c Mon Sep 17 00:00:00 2001
From: Yuta Saito <kateinoigakukun@gmail.com>
Date: Wed, 14 Feb 2024 12:07:39 +0000
Subject: [PATCH] [wasm] Port ProcessInfo for WASI platform

---
 CoreFoundation/Base.subproj/CFPlatform.c | 46 ++++++++++++++++++++----
 CoreFoundation/Base.subproj/CFPriv.h     |  6 +---
 2 files changed, 41 insertions(+), 11 deletions(-)

diff --git a/CoreFoundation/Base.subproj/CFPlatform.c b/CoreFoundation/Base.subproj/CFPlatform.c
index acb5c709..d89d8192 100644
--- a/CoreFoundation/Base.subproj/CFPlatform.c
+++ b/CoreFoundation/Base.subproj/CFPlatform.c
@@ -105,7 +105,6 @@ CF_PRIVATE const wchar_t *_CFDLLPath(void) {
 }
 #endif // TARGET_OS_WIN32
 
-#if !TARGET_OS_WASI
 static const char *__CFProcessPath = NULL;
 static const char *__CFprogname = NULL;
 
@@ -188,6 +187,31 @@ const char *_CFProcessPath(void) {
         __CFprogname = __CFProcessPath;
     }
     return __CFProcessPath;
+#elif TARGET_OS_WASI
+    __wasi_errno_t err;
+    size_t argc;
+    size_t argv_buf_size;
+    err = __wasi_args_sizes_get(&argc, &argv_buf_size);
+    if (err != 0) {
+        __CFProcessPath = "";
+        __CFprogname = __CFProcessPath;
+        return __CFProcessPath;
+    }
+    char *argv_buf = malloc(argv_buf_size);
+    char **argv = calloc(argc, sizeof(char *));
+    err = __wasi_args_get((uint8_t **)argv, (uint8_t *)argv_buf);
+    if (err != 0) {
+        __CFProcessPath = "";
+        __CFprogname = __CFProcessPath;
+        free(argv_buf);
+        free(argv);
+        return __CFProcessPath;
+    }
+    _CFSetProgramNameFromPath(argv[0]);
+    free(argv_buf);
+    free(argv);
+    return __CFProcessPath;
+
 #else // TARGET_OS_BSD
     char *argv0 = NULL;
 
@@ -250,7 +274,6 @@ const char *_CFProcessPath(void) {
     return __CFProcessPath;
 #endif
 }
-#endif // TARGET_OS_WASI
 
 #if TARGET_OS_MAC || TARGET_OS_WIN32 || TARGET_OS_BSD
 CF_CROSS_PLATFORM_EXPORT Boolean _CFIsMainThread(void) {
@@ -275,7 +298,6 @@ Boolean _CFIsMainThread(void) {
 }
 #endif // TARGET_OS_LINUX
 
-#if !TARGET_OS_WASI
 CF_PRIVATE CFStringRef _CFProcessNameString(void) {
     static CFStringRef __CFProcessNameString = NULL;
     if (!__CFProcessNameString) {
@@ -294,7 +316,6 @@ CF_PRIVATE CFStringRef _CFProcessNameString(void) {
     }
     return __CFProcessNameString;
 }
-#endif // !TARGET_OS_WASI
 
 #if TARGET_OS_MAC || TARGET_OS_LINUX || TARGET_OS_BSD
 
@@ -389,16 +410,20 @@ static CFURLRef _CFCopyHomeDirURLForUser(const char *username, bool fallBackToHo
 
 #endif
 
-#if !TARGET_OS_WASI
 #define CFMaxHostNameLength	256
 #define CFMaxHostNameSize	(CFMaxHostNameLength+1)
 
 CF_PRIVATE CFStringRef _CFStringCreateHostName(void) {
+#if TARGET_OS_WASI
+    // WASI doesn't have a concept of a hostname
+    return CFSTR("");
+#else
     char myName[CFMaxHostNameSize];
 
     // return @"" instead of nil a la CFUserName() and Ali Ozer
     if (0 != gethostname(myName, CFMaxHostNameSize)) return CFSTR("");
     return CFStringCreateWithCString(kCFAllocatorSystemDefault, myName, kCFPlatformInterfaceStringEncoding);
+#endif
 }
 
 /* These are sanitized versions of the above functions. We might want to eliminate the above ones someday.
@@ -435,6 +460,8 @@ CF_EXPORT CFStringRef CFCopyUserName(void) {
                 result = CFStringCreateWithCString(kCFAllocatorSystemDefault, cname, kCFPlatformInterfaceStringEncoding);
             }
 	}
+#elif TARGET_OS_WASI
+    // WASI does not have user concept
 #else
 #error "Please add an implementation for CFCopyUserName() that copies the account username"
 #endif
@@ -464,6 +491,8 @@ CF_CROSS_PLATFORM_EXPORT CFStringRef CFCopyFullUserName(void) {
     GetUserNameExW(NameDisplay, (LPWSTR)wszBuffer, &ulLength);
 
     result = CFStringCreateWithCharacters(kCFAllocatorSystemDefault, (UniChar *)wszBuffer, ulLength);
+#elif TARGET_OS_WASI
+    // WASI does not have user concept
 #else
 #error "Please add an implementation for CFCopyFullUserName() that copies the full (display) user name"
 #endif
@@ -530,6 +559,9 @@ CFURLRef CFCopyHomeDirectoryURL(void) {
     if (testPath) CFRelease(testPath);
 
     return retVal;
+#elif TARGET_OS_WASI
+    // WASI does not have user concept
+    return NULL;
 #else
 #error Dont know how to compute users home directories on this platform
 #endif
@@ -661,6 +693,9 @@ CF_EXPORT CFURLRef CFCopyHomeDirectoryURLForUser(CFStringRef uName) {
     CFAllocatorDeallocate(kCFAllocatorSystemDefault, pwszUserName);
 
     return url;
+#elif TARGET_OS_WASI
+    // WASI does not have user concept
+    return NULL;
 #else
 #error Dont know how to compute users home directories on this platform
 #endif
@@ -669,7 +704,6 @@ CF_EXPORT CFURLRef CFCopyHomeDirectoryURLForUser(CFStringRef uName) {
 
 #undef CFMaxHostNameLength
 #undef CFMaxHostNameSize
-#endif // !TARGET_OS_WASI
 
 #if TARGET_OS_WIN32
 CF_INLINE CFIndex strlen_UniChar(const UniChar* p) {
diff --git a/CoreFoundation/Base.subproj/CFPriv.h b/CoreFoundation/Base.subproj/CFPriv.h
index 692a106a..73292b09 100644
--- a/CoreFoundation/Base.subproj/CFPriv.h
+++ b/CoreFoundation/Base.subproj/CFPriv.h
@@ -57,19 +57,17 @@ CF_EXTERN_C_BEGIN
 
 CF_EXPORT void _CFRuntimeSetCFMPresent(void *a);
 
-#if !TARGET_OS_WASI
 CF_EXPORT const char *_CFProcessPath(void);
 CF_EXPORT const char **_CFGetProcessPath(void);
 CF_EXPORT const char **_CFGetProgname(void);
 
-#if !TARGET_OS_WIN32
+#if !TARGET_OS_WIN32 && !TARGET_OS_WASI
 #include <sys/types.h>
 
 CF_EXPORT void _CFGetUGIDs(uid_t *euid, gid_t *egid);
 CF_EXPORT uid_t _CFGetEUID(void);
 CF_EXPORT uid_t _CFGetEGID(void);
 #endif
-#endif
 
 #if (TARGET_OS_MAC && !(TARGET_OS_IPHONE || TARGET_OS_LINUX))
 CF_EXPORT void _CFRunLoopSetCurrent(CFRunLoopRef rl);
@@ -166,7 +164,6 @@ CF_EXPORT Boolean _CFStringGetFileSystemRepresentation(CFStringRef string, UInt8
 /* If this is publicized, we might need to create a GetBytesPtr type function as well. */
 CF_EXPORT CFStringRef _CFStringCreateWithBytesNoCopy(CFAllocatorRef alloc, const UInt8 *bytes, CFIndex numBytes, CFStringEncoding encoding, Boolean externalFormat, CFAllocatorRef contentsDeallocator);
 
-#if !TARGET_OS_WASI
 /* These return NULL on MacOS 8 */
 // This one leaks the returned string in order to be thread-safe.
 // CF cannot help you in this matter if you continue to use this SPI.
@@ -178,7 +175,6 @@ CFStringRef CFCopyUserName(void);
 
 CF_EXPORT
 CFURLRef CFCopyHomeDirectoryURLForUser(CFStringRef uName);	/* Pass NULL for the current user's home directory */
-#endif
 
 
 /*
-- 
2.43.0

