From 7e1bff640f4b113022068b012dd07e6f64fe1a99 Mon Sep 17 00:00:00 2001
From: Yuta Saito <kateinoigakukun@gmail.com>
Date: Wed, 14 Feb 2024 12:42:51 +0000
Subject: [PATCH] [wasm] Port FileManager for WASI platform

---
 .../Base.subproj/ForSwiftFoundationOnly.h     | 16 ++++-
 Sources/Foundation/Data.swift                 |  5 +-
 Sources/Foundation/FileHandle.swift           |  6 ++
 Sources/Foundation/FileManager+POSIX.swift    | 69 +++++++++++++++++++
 Sources/Foundation/FileManager.swift          | 13 +++-
 Sources/Foundation/NSData.swift               |  3 +-
 Sources/Foundation/NSPathUtilities.swift      |  2 -
 Sources/Foundation/NSURL.swift                | 14 ----
 8 files changed, 102 insertions(+), 26 deletions(-)

diff --git a/CoreFoundation/Base.subproj/ForSwiftFoundationOnly.h b/CoreFoundation/Base.subproj/ForSwiftFoundationOnly.h
index 37d38f26..bac39185 100644
--- a/CoreFoundation/Base.subproj/ForSwiftFoundationOnly.h
+++ b/CoreFoundation/Base.subproj/ForSwiftFoundationOnly.h
@@ -45,7 +45,7 @@
 #if _POSIX_THREADS
 #include <pthread.h>
 #endif
-#if defined(__unix__) || (defined(__APPLE__) && defined(__MACH__))
+#if defined(__unix__) || (defined(__APPLE__) && defined(__MACH__)) || defined(__wasi__)
 #include <dirent.h>
 #endif
 
@@ -565,11 +565,11 @@ CF_CROSS_PLATFORM_EXPORT int _CFOpenFileWithMode(const char *path, int opts, mod
 CF_CROSS_PLATFORM_EXPORT void *_CFReallocf(void *ptr, size_t size);
 CF_CROSS_PLATFORM_EXPORT int _CFOpenFile(const char *path, int opts);
 
-#if defined(__unix__) || (defined(__APPLE__) && defined(__MACH__))
+#if defined(__unix__) || (defined(__APPLE__) && defined(__MACH__)) || defined(__wasi__)
 static inline int _direntNameLength(struct dirent *entry) {
 #ifdef _D_EXACT_NAMLEN  // defined on Linux
     return _D_EXACT_NAMLEN(entry);
-#elif TARGET_OS_LINUX || TARGET_OS_ANDROID
+#elif TARGET_OS_LINUX || TARGET_OS_ANDROID || TARGET_OS_WASI
     return strlen(entry->d_name);
 #else
     return entry->d_namlen;
@@ -582,11 +582,21 @@ static inline char *_direntName(struct dirent *entry) {
 
 // major() and minor() might be implemented as macros or functions.
 static inline unsigned int _dev_major(dev_t rdev) {
+#if !TARGET_OS_WASI
     return major(rdev);
+#else
+    // WASI does not have device numbers
+    return 0;
+#endif
 }
 
 static inline unsigned int _dev_minor(dev_t rdev) {
+#if !TARGET_OS_WASI
     return minor(rdev);
+#else
+    // WASI does not have device numbers
+    return 0;
+#endif
 }
 
 #endif
diff --git a/Sources/Foundation/Data.swift b/Sources/Foundation/Data.swift
index 23254e6b..091adbfa 100644
--- a/Sources/Foundation/Data.swift
+++ b/Sources/Foundation/Data.swift
@@ -36,6 +36,7 @@
 @usableFromInline let memcpy = Musl.memcpy
 @usableFromInline let memcmp = Musl.memcmp
 #elseif canImport(WASILibc)
+@_implementationOnly import wasi_emulated_mman
 @usableFromInline let calloc = WASILibc.calloc
 @usableFromInline let malloc = WASILibc.malloc
 @usableFromInline let free = WASILibc.free
@@ -2048,7 +2049,6 @@ public struct Data : ReferenceConvertible, Equatable, Hashable, RandomAccessColl
         }
     }
     
-#if !os(WASI)
     /// Initialize a `Data` with the contents of a `URL`.
     ///
     /// - parameter url: The `URL` to read.
@@ -2061,7 +2061,6 @@ public struct Data : ReferenceConvertible, Equatable, Hashable, RandomAccessColl
             return Data(bytes: d.bytes, count: d.length)
         }
     }
-#endif
     
     /// Initialize a `Data` from a Base-64 encoded String using the given options.
     ///
@@ -2325,7 +2324,6 @@ public struct Data : ReferenceConvertible, Equatable, Hashable, RandomAccessColl
     }
 #endif
     
-#if !os(WASI)
     /// Write the contents of the `Data` to a location.
     ///
     /// - parameter url: The location to write the data into.
@@ -2346,7 +2344,6 @@ public struct Data : ReferenceConvertible, Equatable, Hashable, RandomAccessColl
 #endif
         }
     }
-#endif
     
     // MARK: -
     
diff --git a/Sources/Foundation/FileHandle.swift b/Sources/Foundation/FileHandle.swift
index 285bed70..5fb7258c 100644
--- a/Sources/Foundation/FileHandle.swift
+++ b/Sources/Foundation/FileHandle.swift
@@ -27,6 +27,12 @@ import Musl
 fileprivate let _read = Musl.read(_:_:_:)
 fileprivate let _write = Musl.write(_:_:_:)
 fileprivate let _close = Musl.close(_:)
+#elseif canImport(WASILibc)
+import WASILibc
+@_implementationOnly import wasi_emulated_mman
+fileprivate let _read = WASILibc.read(_:_:_:)
+fileprivate let _write = WASILibc.write(_:_:_:)
+fileprivate let _close = WASILibc.close(_:)
 #endif
 
 #if canImport(WinSDK)
diff --git a/Sources/Foundation/FileManager+POSIX.swift b/Sources/Foundation/FileManager+POSIX.swift
index 1c50e458..0f8e941c 100644
--- a/Sources/Foundation/FileManager+POSIX.swift
+++ b/Sources/Foundation/FileManager+POSIX.swift
@@ -106,6 +106,32 @@ extension FileManager {
                 return nil
             }
             urls = mountPoints(statBuf, Int(fsCount))
+#elseif os(WASI)
+        // Skip the first three file descriptors, which are reserved for stdin, stdout, and stderr.
+        var fd: __wasi_fd_t = 3
+        let __WASI_PREOPENTYPE_DIR: UInt8 = 0
+        while true {
+            var prestat = __wasi_prestat_t()
+            guard __wasi_fd_prestat_get(fd, &prestat) == 0 else {
+                break
+            }
+
+            if prestat.tag == __WASI_PREOPENTYPE_DIR {
+                var buf = [UInt8](repeating: 0, count: Int(prestat.u.dir.pr_name_len))
+                guard __wasi_fd_prestat_dir_name(fd, &buf, prestat.u.dir.pr_name_len) == 0 else {
+                    break
+                }
+                let path = buf.withUnsafeBufferPointer { buf in
+                  guard let baseAddress = buf.baseAddress else {
+                    return ""
+                  }
+                  let base = UnsafeRawPointer(baseAddress).assumingMemoryBound(to: Int8.self)
+                  return string(withFileSystemRepresentation: base, length: buf.count)
+                }
+                urls.append(URL(fileURLWithPath: path, isDirectory: true))
+            }
+            fd += 1
+        }
 #else
 #error("Requires a platform-specific implementation")
 #endif
@@ -454,6 +480,10 @@ extension FileManager {
     }
     
     internal func _attributesOfFileSystemIncludingBlockSize(forPath path: String) throws -> (attributes: [FileAttributeKey : Any], blockSize: UInt64?) {
+    #if os(WASI)
+        // WASI doesn't have statvfs
+        throw _NSErrorWithErrno(ENOTSUP, reading: true, path: path)
+    #else
         var result: [FileAttributeKey:Any] = [:]
         var finalBlockSize: UInt64?
         
@@ -486,6 +516,7 @@ extension FileManager {
             finalBlockSize = blockSize
         }
         return (attributes: result, blockSize: finalBlockSize)
+    #endif // os(WASI)
     }
 
     internal func _createSymbolicLink(atPath path: String, withDestinationPath destPath: String) throws {
@@ -515,6 +546,9 @@ extension FileManager {
     }
         
     internal func _recursiveDestinationOfSymbolicLink(atPath path: String) throws -> String {
+        #if canImport(WASILibc)
+        throw _NSErrorWithErrno(ENOTSUP, reading: true, path: path)
+        #else
         // Throw error if path is not a symbolic link:
         let path = try _destinationOfSymbolicLink(atPath: path)
         
@@ -528,10 +562,14 @@ extension FileManager {
         }
 
         return String(cString: resolvedPath)
+        #endif
     }
 
     /* Returns a String with a canonicalized path for the element at the specified path. */
     internal func _canonicalizedPath(toFileAtPath path: String) throws -> String {
+        #if canImport(WASILibc)
+        throw _NSErrorWithErrno(ENOTSUP, reading: true, path: path)
+        #else
         let bufSize = Int(PATH_MAX + 1)
         var buf = [Int8](repeating: 0, count: bufSize)
         let done = try _fileSystemRepresentation(withPath: path) {
@@ -542,6 +580,7 @@ extension FileManager {
         }
         
         return self.string(withFileSystemRepresentation: buf, length: strlen(buf))
+        #endif
     }
 
     internal func _readFrom(fd: Int32, toBuffer buffer: UnsafeMutablePointer<UInt8>, length bytesToRead: Int, filename: String) throws -> Int {
@@ -599,12 +638,14 @@ extension FileManager {
         }
         defer { close(dstfd) }
 
+        #if !os(WASI)
         // Set the file permissions using fchmod() instead of when open()ing to avoid umask() issues
         let permissions = fileInfo.st_mode & ~S_IFMT
         guard fchmod(dstfd, permissions) == 0 else {
             throw _NSErrorWithErrno(errno, reading: false, path: dstPath,
                 extraUserInfo: extraErrorInfo(srcPath: srcPath, dstPath: dstPath, userVariant: variant))
         }
+        #endif
 
         if fileInfo.st_size == 0 {
             // no copying required
@@ -749,6 +790,10 @@ extension FileManager {
             if rmdir(fsRep) == 0 {
                 return
             } else if errno == ENOTEMPTY {
+                #if os(WASI)
+                // wasi-libc, which is based on musl, does not provide fts(3)
+                throw _NSErrorWithErrno(ENOTSUP, reading: false, path: path)
+                #else
                 let ps = UnsafeMutablePointer<UnsafeMutablePointer<Int8>?>.allocate(capacity: 2)
                 ps.initialize(to: UnsafeMutablePointer(mutating: fsRep))
                 ps.advanced(by: 1).initialize(to: nil)
@@ -791,6 +836,7 @@ extension FileManager {
                 } else {
                     let _ = _NSErrorWithErrno(ENOTEMPTY, reading: false, path: path)
                 }
+                #endif
             } else if errno != ENOTDIR {
                 throw _NSErrorWithErrno(errno, reading: false, path: path)
             } else if unlink(fsRep) != 0 {
@@ -893,6 +939,7 @@ extension FileManager {
                     return false
                 }
 
+                #if !os(WASI) // WASI doesn't have ownership concept
                 // Stat the parent directory, if that fails, return false.
                 let parentS = try _lstatFile(atPath: path, withFileSystemRepresentation: parentFsRep)
 
@@ -903,6 +950,7 @@ extension FileManager {
                     // If the current user owns the file, return true.
                     return s.st_uid == getuid()
                 }
+                #endif
 
                 // Return true as the best guess.
                 return true
@@ -1073,6 +1121,26 @@ extension FileManager {
         return temp._bridgeToObjectiveC().appendingPathComponent(dest)
     }
 
+    #if os(WASI)
+    // For platforms that don't support FTS, we just throw an error for now.
+    // TODO: Provide readdir(2) based implementation here or FTS in wasi-libc?
+    internal class NSURLDirectoryEnumerator : DirectoryEnumerator {
+        var _url : URL
+        var _errorHandler : ((URL, Error) -> Bool)?
+
+        init(url: URL, options: FileManager.DirectoryEnumerationOptions, errorHandler: ((URL, Error) -> Bool)?) {
+            _url = url
+            _errorHandler = errorHandler
+        }
+
+        override func nextObject() -> Any? {
+            if let handler = _errorHandler {
+                _ = handler(_url, _NSErrorWithErrno(ENOTSUP, reading: true, url: _url))
+            }
+            return nil
+        }
+    }
+    #else
     internal class NSURLDirectoryEnumerator : DirectoryEnumerator {
         var _url : URL
         var _options : FileManager.DirectoryEnumerationOptions
@@ -1206,6 +1274,7 @@ extension FileManager {
             return nil
         }
     }
+    #endif
 
     internal func _updateTimes(atPath path: String, withFileSystemRepresentation fsr: UnsafePointer<Int8>, creationTime: Date? = nil, accessTime: Date? = nil, modificationTime: Date? = nil) throws {
         let stat = try _lstatFile(atPath: path, withFileSystemRepresentation: fsr)
diff --git a/Sources/Foundation/FileManager.swift b/Sources/Foundation/FileManager.swift
index 1aa3038a..cfe264f5 100644
--- a/Sources/Foundation/FileManager.swift
+++ b/Sources/Foundation/FileManager.swift
@@ -21,6 +21,10 @@ import CRT
 import WinSDK
 #endif
 
+#if os(WASI)
+import WASILibc
+#endif
+
 #if os(Windows)
 internal typealias NativeFSRCharType = WCHAR
 internal let NativeFSREncoding = String.Encoding.utf16LittleEndian.rawValue
@@ -384,6 +388,10 @@ open class FileManager : NSObject {
                 
                 switch attribute {
                 case .posixPermissions:
+#if os(WASI)
+                    // WASI does not have permission concept
+                    throw _NSErrorWithErrno(ENOTSUP, reading: false, path: path)
+#else
                     guard let number = attributeValues[attribute] as? NSNumber else {
                         fatalError("Can't set file permissions to \(attributeValues[attribute] as Any?)")
                     }
@@ -400,6 +408,7 @@ open class FileManager : NSObject {
                     guard result == 0 else {
                         throw _NSErrorWithErrno(errno, reading: false, path: path)
                     }
+#endif // os(WASI)
                 
                 case .modificationDate: fallthrough
                 case ._accessDate:
@@ -567,7 +576,7 @@ open class FileManager : NSObject {
         result[.deviceIdentifier] = NSNumber(value: UInt64(s.st_rdev))
         let attributes = try windowsFileAttributes(atPath: path)
         let type = FileAttributeType(attributes: attributes, atPath: path)
-#else
+#elseif !os(WASI)
         if let pwd = getpwuid(s.st_uid), pwd.pointee.pw_name != nil {
             let name = String(cString: pwd.pointee.pw_name)
             result[.ownerAccountName] = name
@@ -577,9 +586,9 @@ open class FileManager : NSObject {
             let name = String(cString: grd.pointee.gr_name)
             result[.groupOwnerAccountName] = name
         }
+#endif
 
         let type = FileAttributeType(statMode: mode_t(s.st_mode))
-#endif
         result[.type] = type
 
         if type == .typeBlockSpecial || type == .typeCharacterSpecial {
diff --git a/Sources/Foundation/NSData.swift b/Sources/Foundation/NSData.swift
index e004c950..fd494ce7 100644
--- a/Sources/Foundation/NSData.swift
+++ b/Sources/Foundation/NSData.swift
@@ -498,6 +498,8 @@ open class NSData : NSObject, NSCopying, NSMutableCopying, NSSecureCoding {
             let createMode = Int(Glibc.S_IRUSR) | Int(Glibc.S_IWUSR) | Int(Glibc.S_IRGRP) | Int(Glibc.S_IWGRP) | Int(Glibc.S_IROTH) | Int(Glibc.S_IWOTH)
 #elseif canImport(Musl)
             let createMode = Int(Musl.S_IRUSR) | Int(Musl.S_IWUSR) | Int(Musl.S_IRGRP) | Int(Musl.S_IWGRP) | Int(Musl.S_IROTH) | Int(Musl.S_IWOTH)
+#elseif canImport(WASILibc)
+            let createMode = Int(WASILibc.S_IRUSR) | Int(WASILibc.S_IWUSR) | Int(WASILibc.S_IRGRP) | Int(WASILibc.S_IWGRP) | Int(WASILibc.S_IROTH) | Int(WASILibc.S_IWOTH)
 #endif
             guard let fh = FileHandle(path: path, flags: flags, createMode: createMode) else {
                 throw _NSErrorWithErrno(errno, reading: false, path: path)
@@ -545,7 +547,6 @@ open class NSData : NSObject, NSCopying, NSMutableCopying, NSSecureCoding {
         }
         try write(toFile: url.path, options: writeOptionsMask)
     }
-#endif
 
     // MARK: - Bytes
     /// Copies a number of bytes from the start of the data object into a given buffer.
diff --git a/Sources/Foundation/NSPathUtilities.swift b/Sources/Foundation/NSPathUtilities.swift
index 1726b351..cfba2728 100644
--- a/Sources/Foundation/NSPathUtilities.swift
+++ b/Sources/Foundation/NSPathUtilities.swift
@@ -655,7 +655,6 @@ extension NSString {
 
 }
 
-#if !os(WASI)
 extension FileManager {
     public enum SearchPathDirectory: UInt {
         
@@ -831,4 +830,3 @@ internal func _NSCleanupTemporaryFile(_ auxFilePath: String, _ filePath: String)
     })
 #endif
 }
-#endif
diff --git a/Sources/Foundation/NSURL.swift b/Sources/Foundation/NSURL.swift
index 4b6a2a5b..4d31e2ba 100644
--- a/Sources/Foundation/NSURL.swift
+++ b/Sources/Foundation/NSURL.swift
@@ -556,9 +556,6 @@ open class NSURL : NSObject, NSSecureCoding, NSCopying {
     // TODO: should be `checkResourceIsReachableAndReturnError` with autoreleased error parameter.
     // Currently Autoreleased pointers is not supported on Linux.
     open func checkResourceIsReachable() throws -> Bool {
-#if os(WASI)
-        return false
-#else
         guard isFileURL,
             let path = path else {
                 throw NSError(domain: NSCocoaErrorDomain,
@@ -574,7 +571,6 @@ open class NSURL : NSObject, NSSecureCoding, NSCopying {
         }
         
         return true
-#endif
     }
 
     /* Returns a file path URL that refers to the same resource as a specified URL. File path URLs use a file system style path. An error will occur if the url parameter is not a file URL. A file reference URL's resource must exist and be reachable to be converted to a file path URL. Symbol is present in iOS 4, but performs no operation.
@@ -918,12 +914,8 @@ extension NSURL {
         if selfPath.isAbsolutePath {
             absolutePath = selfPath
         } else {
-#if os(WASI)
-            return nil
-#else
             let workingDir = FileManager.default.currentDirectoryPath
             absolutePath = workingDir._bridgeToObjectiveC().appendingPathComponent(selfPath)
-#endif
         }
 
 #if os(Windows)
@@ -971,20 +963,16 @@ extension NSURL {
 
             default:
                 resolvedPath = resolvedPath._bridgeToObjectiveC().appendingPathComponent(component)
-#if !os(WASI)
                 if let destination = FileManager.default._tryToResolveTrailingSymlinkInPath(resolvedPath) {
                     resolvedPath = destination
                 }
-#endif
             }
         }
 
         // It might be a responsibility of NSURL(fileURLWithPath:). Check it.
         var isExistingDirectory: ObjCBool = false
 
-#if !os(WASI)
         let _ = FileManager.default.fileExists(atPath: resolvedPath, isDirectory: &isExistingDirectory)
-#endif
 
         if excludeSystemDirs {
             resolvedPath = resolvedPath._tryToRemovePathPrefix("/private") ?? resolvedPath
@@ -1063,7 +1051,6 @@ extension NSURL : _StructTypeBridgeable {
 
 // -----
 
-#if !os(WASI)
 internal func _CFSwiftURLCopyResourcePropertyForKey(_ url: CFTypeRef, _ key: CFString, _ valuePointer: UnsafeMutablePointer<Unmanaged<CFTypeRef>?>?, _ errorPointer: UnsafeMutablePointer<Unmanaged<CFError>?>?) -> _DarwinCompatibleBoolean {
     do {
         let key = URLResourceKey(rawValue: key._swiftObject)
@@ -1597,7 +1584,6 @@ fileprivate extension URLResourceValuesStorage {
         }
     }
 }
-#endif
 
 // -----
 
-- 
2.43.0

