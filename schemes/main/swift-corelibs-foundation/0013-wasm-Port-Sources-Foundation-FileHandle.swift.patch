From 2bd0a22f1c4128709193988779cae792f7977ff6 Mon Sep 17 00:00:00 2001
From: Yuta Saito <kateinoigakukun@gmail.com>
Date: Fri, 8 Mar 2024 09:30:02 +0000
Subject: [PATCH] [wasm] Port Sources/Foundation/FileHandle.swift

* Unsupport background read/write operations
* Unsupport Pipe
---
 Sources/Foundation/FileHandle.swift | 29 ++++++++++++++++++++++++++---
 1 file changed, 26 insertions(+), 3 deletions(-)

diff --git a/Sources/Foundation/FileHandle.swift b/Sources/Foundation/FileHandle.swift
index 5fb7258c..10e6dc9c 100644
--- a/Sources/Foundation/FileHandle.swift
+++ b/Sources/Foundation/FileHandle.swift
@@ -8,7 +8,9 @@
 //
 
 @_implementationOnly import CoreFoundation
+#if canImport(Dispatch)
 import Dispatch
+#endif
 
 // FileHandle has a .read(upToCount:) method. Just invoking read() will cause an ambiguity warning. Use _read instead.
 // Same with close()/.close().
@@ -90,6 +92,7 @@ open class FileHandle : NSObject {
 
     private var _closeOnDealloc: Bool
 
+#if canImport(Dispatch)
     private var currentBackgroundActivityOwner: AnyObject? // Guarded by privateAsyncVariablesLock
     
     private var readabilitySource: DispatchSourceProtocol? // Guarded by privateAsyncVariablesLock
@@ -213,6 +216,7 @@ open class FileHandle : NSObject {
             }
         }
     }
+#endif // canImport(Dispatch)
 
     open var availableData: Data {
         _checkFileHandle()
@@ -626,6 +630,7 @@ open class FileHandle : NSObject {
     }
     
     private func performOnQueueIfExists(_ block: () throws -> Void) throws {
+#if canImport(Dispatch)
         if let queue = queueIfExists {
             var theError: Swift.Error?
             queue.sync {
@@ -637,6 +642,9 @@ open class FileHandle : NSObject {
         } else {
             try block()
         }
+#else
+        try block()
+#endif
     }
     
     @available(swift 5.0)
@@ -651,6 +659,7 @@ open class FileHandle : NSObject {
         guard self != FileHandle._nulldeviceFileHandle else { return }
         guard _isPlatformHandleValid else { return }
         
+        #if canImport(Dispatch)
         privateAsyncVariablesLock.lock()
         writabilitySource?.cancel()
         readabilitySource?.cancel()
@@ -659,6 +668,7 @@ open class FileHandle : NSObject {
         writabilitySource = nil
         readabilitySource = nil
         privateAsyncVariablesLock.unlock()
+        #endif
 
 #if os(Windows)
             // SR-13822 - Not Closing the file descriptor on Windows causes a Stack Overflow
@@ -861,6 +871,9 @@ extension FileHandle {
     }
 
     open func readInBackgroundAndNotify(forModes modes: [RunLoop.Mode]?) {
+#if !canImport(Dispatch)
+        NSUnsupported()
+#else
         _checkFileHandle()
         
         privateAsyncVariablesLock.lock()
@@ -915,6 +928,7 @@ extension FileHandle {
           operation(data, error)
         }
 #endif
+#endif // canImport(Dispatch)
     }
     
     open func readToEndOfFileInBackgroundAndNotify() {
@@ -922,6 +936,9 @@ extension FileHandle {
     }
     
     open func readToEndOfFileInBackgroundAndNotify(forModes modes: [RunLoop.Mode]?) {
+#if !canImport(Dispatch) || !canImport(Dispatch)
+        NSUnsupported()
+#else
         privateAsyncVariablesLock.lock()
         guard currentBackgroundActivityOwner == nil else { fatalError("No two activities can occur at the same time") }
         
@@ -963,11 +980,12 @@ extension FileHandle {
                 NotificationQueue.default.enqueue(Notification(name: .NSFileHandleReadToEndOfFileCompletion, object: self, userInfo: userInfo), postingStyle: .asap, coalesceMask: .none, forModes: modes)
             }
         }
+#endif
     }
     
     @available(Windows, unavailable, message: "A SOCKET cannot be treated as a fd")
     open func acceptConnectionInBackgroundAndNotify() {
-#if os(Windows)
+#if os(Windows) || !canImport(Dispatch)
         NSUnsupported()
 #else
         acceptConnectionInBackgroundAndNotify(forModes: [.default])
@@ -976,7 +994,7 @@ extension FileHandle {
 
     @available(Windows, unavailable, message: "A SOCKET cannot be treated as a fd")
     open func acceptConnectionInBackgroundAndNotify(forModes modes: [RunLoop.Mode]?) {
-#if os(Windows)
+#if os(Windows) || !canImport(Dispatch)
         NSUnsupported()
 #else
         let owner = monitor(forReading: true, resumed: false) { (handle, source) in
@@ -1014,6 +1032,9 @@ extension FileHandle {
     }
     
     open func waitForDataInBackgroundAndNotify(forModes modes: [RunLoop.Mode]?) {
+#if !canImport(Dispatch)
+        NSUnsupported()
+#else
         let owner = monitor(forReading: true, resumed: false) { (handle, source) in
             source.cancel()
             DispatchQueue.main.async {
@@ -1031,6 +1052,7 @@ extension FileHandle {
         privateAsyncVariablesLock.unlock()
         
         owner.resume()
+#endif
     }
 }
 
@@ -1052,6 +1074,8 @@ open class Pipe: NSObject {
                                                closeOnDealloc: true)
         self.fileHandleForWriting = FileHandle(handle: hWritePipe!,
                                                closeOnDealloc: true)
+#elseif os(WASI)
+        NSUnsupported()
 #else
         /// the `pipe` system call creates two `fd` in a malloc'ed area
         let fds = UnsafeMutablePointer<Int32>.allocate(capacity: 2)
@@ -1078,4 +1102,3 @@ open class Pipe: NSObject {
         super.init()
     }
 }
-
-- 
2.43.0

